using System;
using System.Linq;
using System.Runtime.Serialization;

namespace dodSON.Core.Cryptography
{
    /// <summary>
    /// Provides mechanisms for viewing and validating salted password hashes.
    /// <br/>
    /// Hashing passwords is a way of taking a password, in this case a <see cref="System.Security.SecureString"/>, and creating a 
    /// cryptic, fixed-length <see cref="PasswordSaltHash"/> from it. 
    /// The <see cref="PasswordSaltHash"/> is generated by combining the salt with the password and generating a one-way hash. 
    /// The salt value should be a random series of bytes and does not, necessarily, need to be stored in a protected fashion.
    /// The password, in the form of a <see cref="System.Security.SecureString"/>, is only used to create the <see cref="PasswordSaltHash"/>
    /// and is in open memory for as little time as possible.
    /// </summary>
    /// <example>
    /// The following code example will generate random text, encrypt and decrypt the text and test the results.
    /// <para>
    /// Create a console application.<br/><br/>
    /// Be sure to add the following line to the using group at the top of the .cs file. 
    /// This will ensure you can access the System.Security.SecureString Extensions <see cref="dodSON.Core.Cryptography.CryptographyExtensions.AppendBytes"/> and
    /// <see cref="dodSON.Core.Cryptography.CryptographyExtensions.AppendChars"/>.
    /// </para>
    /// <code>
    /// using dodSON.Core.Cryptography;
    /// </code>
    /// <para>
    /// Then, add the following code:
    /// </para>
    /// <code>
    /// static void Main(string[] args)
    /// {
    ///     // create source text and convert to a byte array
    ///     var source = dodSON.Core.Common.LoremIpsumGenerator.GenerateParagraph(14, true);
    ///     var sourceData = System.Text.Encoding.ASCII.GetBytes(source);
    ///     
    ///     // create a salted password using a System.Security.SecureString
    ///     // NOTE:    DO NOT store passwords in strings like below. This password is embedded in the executable, as a string, in the clear!
    ///     //          Be sure the source of password information is secure and transitory.
    ///     var passwordSecureStr = new System.Security.SecureString();
    ///     passwordSecureStr.AppendBytes(System.Text.Encoding.ASCII.GetBytes("BAD-Pa$$w0rd"), System.Text.Encoding.ASCII, true);
    ///     var saltedPassword = new dodSON.Core.Cryptography.SaltedPassword(
    ///                                 new System.Security.Cryptography.SHA512CryptoServiceProvider(), passwordSecureStr, 128);
    ///     
    ///     // create encryption configuration
    ///     var symmetricAlgorithmType = typeof(System.Security.Cryptography.TripleDESCryptoServiceProvider);
    ///     var encryptorConfiguration = new dodSON.Core.Cryptography.EncryptorConfiguration(saltedPassword, symmetricAlgorithmType);
    ///     
    ///     // create encryptor
    ///     var encryptor = new dodSON.Core.Cryptography.StackableEncryptor(encryptorConfiguration);
    ///     
    ///     // encrypt data
    ///     var encryptedData = encryptor.Encrypt(sourceData);
    ///     
    ///     // decrypt encrypted-data
    ///     var decryptedData = encryptor.Decrypt(encryptedData);
    ///     
    ///     // compare original data with transformed data
    ///     var isSame = sourceData.SequenceEqual(decryptedData);
    ///     
    ///     // display results
    ///     Console.WriteLine(source);
    ///     Console.WriteLine();
    ///     Console.WriteLine("------------------------------------");
    ///     Console.WriteLine(string.Format("Encryption/Decryption Results= {0:N0}", isSame));
    ///     Console.WriteLine(string.Format("Original Data Size = {0:N0}", sourceData.Length));
    ///     Console.WriteLine(string.Format("Encrypted Data Size= {0:N0}", encryptedData.Length));
    ///     Console.WriteLine(string.Format("Decrypted Data Size= {0:N0}", decryptedData.Length));
    ///     Console.WriteLine();
    ///     Console.WriteLine("press anykey...");
    ///     Console.ReadKey(true);
    /// }
    ///     
    /// // This code produces output similar to the following:
    ///
    /// // Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor i
    /// // ncididunt ut labore et dolore magna aliqua. Illum sit singulis tempor ex ad post
    /// // ea persequeris singulis. In rutrum dolor recteque cu in no vis mea. Ex accusam a
    /// // n graecis errem mel commodo tempor persecuti. Pri ei ex sonet pertinax pharetra
    /// // imperdiet in sed. Persius purto id assum mel quas amet per malorum. Fusce electr
    /// // am eros maluisset alia odio delicata ei ne. Aliquid eum ne aliquip tollit obliqu
    /// // e posse ea mel. Purto in ad ad consectetuer ius insolens pertinax imperdiet. Eum
    /// //  accusamus quis elit definiebas gubergren vix duo ut. Nam euripidis cum ex manda
    /// // mus has feugait viderer lacus. Per graeco invidunt usu paulo cu nam ultrices off
    /// // iciis. Summo regione scelerisque pro nullam in eum sollicitudin an. Adipiscing e
    /// // am definitiones dolor lacus dolor cu deseruisse ligula.
    /// //
    /// // ------------------------------------
    /// // Encryption/Decryption Results= True
    /// // Original Data Size = 855
    /// // Encrypted Data Size= 856
    /// // Decrypted Data Size= 855
    /// // 
    /// // press anykey...
    /// </code>
    /// </example>
    [Serializable]
    public class SaltedPassword
            : ISaltedPassword
    {
        #region Public Static Methods

        // TODO: should this function follow the, apparent, dodSON.Core pattern of putting functions like this into ...Helper classes?

        /// <summary>
        /// Generates the Password Salt Result Hash.
        /// </summary>
        /// <param name="hashAlgorithm">The required <see cref="System.Security.Cryptography.HashAlgorithm"/>.</param>
        /// <param name="password">The password.</param>
        /// <param name="salt">The salt.</param>
        /// <returns>The generated Password Salt Result Hash.</returns>
        public static byte[] ComputeResult(System.Security.Cryptography.HashAlgorithm hashAlgorithm,
                                           System.Security.SecureString password,
                                           byte[] salt)
        {
            // merge salt and password
            byte[] saltedPassword = new byte[salt.Length + password.Length];
            byte[] passwordArray = null;
            try
            {
                // add the salt
                for (int i = 0; i < salt.Length; i++) { saltedPassword[i] = salt[i]; }
                // extract the password
                passwordArray = CryptographyHelper.SecureStringToByteArray(password);
                // add the password
                for (int i = 0; i < passwordArray.Length; i++) { saltedPassword[salt.Length + i] = passwordArray[i]; }
                // return result hash
                return hashAlgorithm.ComputeHash(saltedPassword);
            }
            finally
            {
                // clean up
                Array.Clear(saltedPassword, 0, saltedPassword.Length);
                Array.Clear(passwordArray, 0, passwordArray.Length);
            }
        }
        #endregion
        #region Ctor
        private SaltedPassword() { }
        /// <summary>
        /// Will create a <see cref="SaltedPassword"/> using the given password and a cryptographically random salt of the specified length.
        /// </summary>
        /// <param name="hashAlgorithmType">The <see cref="System.Security.Cryptography.HashAlgorithm"/> type to use when creating the result hash.</param>
        /// <param name="password">The password to use when creating the result hash.</param>
        /// <param name="saltLength">The length of the byte array, which will be filled with cryptographically random values, to create for the salt.</param>
        public SaltedPassword(Type hashAlgorithmType,
                              System.Security.SecureString password,
                              int saltLength)
            : this(hashAlgorithmType, password, CryptographyHelper.GenerateCryptographicallyRandomArray(saltLength)) { }
        /// <summary>
        /// Will create a <see cref="SaltedPassword"/> using the given password and salt.
        /// </summary>
        /// <param name="hashAlgorithmType">The <see cref="System.Security.Cryptography.HashAlgorithm"/> type to use when creating the result hash.</param>
        /// <param name="password">The password to use when creating the result hash.</param>
        /// <param name="salt">The salt to use when creating the result hash.</param>
        public SaltedPassword(Type hashAlgorithmType,
                              System.Security.SecureString password,
                              byte[] salt)
            : this()
        {
            // check parameters
            if (hashAlgorithmType == null) { throw new ArgumentNullException(nameof(hashAlgorithmType)); }
            if (!typeof(System.Security.Cryptography.HashAlgorithm).IsAssignableFrom(hashAlgorithmType)) { throw new ArgumentException($"Parameter {nameof(hashAlgorithmType)} must be a type of System.Security.Cryptography.HashAlgorithm."); }
            if (password == null) { throw new ArgumentNullException(nameof(password)); }
            if (password.Length <= 0) { throw new ArgumentOutOfRangeException(nameof(password), $"Parameter {nameof(password)} cannot be empty."); }
            if (salt == null) { throw new ArgumentNullException(nameof(salt)); }
            if (salt.Length <= 0) { throw new ArgumentOutOfRangeException(nameof(salt), $"Parameter {nameof(salt)} cannot be empty."); }
            // store state values
            HashAlgorithmType = hashAlgorithmType;
            using (var hashAlgorithm = HashAlgorithm)
            {
                PasswordSaltHash = ComputeResult(hashAlgorithm, password, salt);
                Salt = salt;
            }
        }
        /// <summary>
        /// Will create a <see cref="SaltedPassword"/> using the given password salt hash and salt.
        /// </summary>
        /// <param name="hashAlgorithmType">The <see cref="System.Security.Cryptography.HashAlgorithm"/> type to use when creating the result hash.</param>
        /// <param name="passwordSaltHash">The password salt hash to use when creating the result hash.</param>
        /// <param name="salt">The salt to use when creating the result hash.</param>
        public SaltedPassword(Type hashAlgorithmType,
                              byte[] passwordSaltHash,
                              byte[] salt)
            : this()
        {
            // check parameters
            if (hashAlgorithmType == null) { throw new ArgumentNullException(nameof(hashAlgorithmType)); }
            if (!typeof(System.Security.Cryptography.HashAlgorithm).IsAssignableFrom(hashAlgorithmType)) { throw new ArgumentException($"Parameter {nameof(hashAlgorithmType)} must be a type of System.Security.Cryptography.HashAlgorithm."); }
            if (passwordSaltHash == null) { throw new ArgumentNullException(nameof(passwordSaltHash)); }
            if (passwordSaltHash.Length <= 0) { throw new ArgumentOutOfRangeException(nameof(passwordSaltHash), $"Parameter {nameof(passwordSaltHash)} cannot be empty."); }
            if (salt == null) { throw new ArgumentNullException(nameof(salt)); }
            if (salt.Length <= 0) { throw new ArgumentOutOfRangeException(nameof(salt), $"Parameter {nameof(salt)} cannot be empty."); }
            // store state values
            HashAlgorithmType = hashAlgorithmType;
            PasswordSaltHash = passwordSaltHash;
            Salt = salt;
        }
        /// <summary>
        /// Instantiates an new instance with the data from the <paramref name="configuration"/>.
        /// </summary>
        /// <param name="configuration">The configuration to use to populate the new instance.</param>
        public SaltedPassword(Configuration.IConfigurationGroup configuration)
            : this()
        {
            if (configuration == null) { throw new ArgumentNullException(nameof(configuration)); }
            if (configuration.Key != "SaltedPassword") { throw new ArgumentException($"Wrong configuration. Configuration Key must equal \"SaltedPassword\". Configuration Key={configuration.Key}", nameof(configuration)); }
            // HashAlgorithmType
            HashAlgorithmType = Type.GetType((string)Core.Configuration.ConfigurationHelper.FindConfigurationItem(configuration, "HashAlgorithmType", typeof(Type)).Value);
            // PasswordSaltHash
            PasswordSaltHash = (byte[])Core.Configuration.ConfigurationHelper.FindConfigurationItem(configuration, "PasswordSaltHash", typeof(byte[])).Value;
            // Salt
            Salt = (byte[])Core.Configuration.ConfigurationHelper.FindConfigurationItem(configuration, "Salt", typeof(byte[])).Value;
        }
        /// <summary>
        /// Will populate a new instance of a <see cref="SaltedPassword"/> using the specified data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> containing data needed to populate this instance.</param>
        /// <param name="context">The destination for this serialization.</param>
        protected SaltedPassword(SerializationInfo info, StreamingContext context)
            : this()
        {
            Salt = (byte[])info.GetValue("Salt", typeof(byte[]));
            PasswordSaltHash = (byte[])info.GetValue("PasswordSaltResultHash", typeof(byte[]));
            var hashAlgorithmType = (string)info.GetValue("HashAlgorithmType", typeof(string));
            HashAlgorithmType = Type.GetType(hashAlgorithmType, true);
        }
        #endregion
        #region ISaltedPassword Methods
        /// <summary>
        /// The salt used to create the computed <see cref="PasswordSaltHash"/>.
        /// </summary>
        public byte[] Salt { get; } = null;
        /// <summary>
        /// The hash created using a password and the <see cref="Salt"/>.
        /// </summary>
        public byte[] PasswordSaltHash { get; } = null;
        /// <summary>
        /// The type of <see cref="System.Security.Cryptography.HashAlgorithm"/> used to create the computed <see cref="PasswordSaltHash"/>.
        /// </summary>
        public Type HashAlgorithmType { get; } = null;
        /// <summary>
        /// An instance of the <see cref="HashAlgorithmType"/>.
        /// </summary>
        public System.Security.Cryptography.HashAlgorithm HashAlgorithm => Common.InstantiationHelper.InvokeDefaultCtor(HashAlgorithmType) as System.Security.Cryptography.HashAlgorithm;
        /// <summary>
        /// Determines if the <paramref name="candidatePasswordSaltHash"/> is equal to the computed <see cref="PasswordSaltHash"/>.
        /// </summary>
        /// <param name="candidatePasswordSaltHash">A byte array to compare against the computed <see cref="PasswordSaltHash"/>.</param>
        /// <returns><b>True</b> if the <paramref name="candidatePasswordSaltHash"/> is equal to the computed <see cref="PasswordSaltHash"/>, otherwise <b>false</b>.</returns>
        public bool IsValid(byte[] candidatePasswordSaltHash)
        {
            if (candidatePasswordSaltHash == null) { return false; }
            return PasswordSaltHash.SequenceEqual(candidatePasswordSaltHash);
        }
        /// <summary>
        /// Determines if the <paramref name="candidateSaltedPassword"/> is equal to this <see cref="ISaltedPassword"/>.
        /// </summary>
        /// <param name="candidateSaltedPassword">The <see cref="ISaltedPassword"/> to compare to this <see cref="ISaltedPassword"/>.</param>
        /// <returns><b>True</b> if the <paramref name="candidateSaltedPassword"/> is equal to this <see cref="ISaltedPassword"/>, otherwise <b>false</b>.</returns>
        public bool IsValid(ISaltedPassword candidateSaltedPassword)
        {
            if (candidateSaltedPassword == null) { return false; }
            return IsValid(candidateSaltedPassword.PasswordSaltHash);
        }
        /// <summary>
        /// Determines if the <paramref name="candidatePassword"/> is valid for this <see cref="SaltedPassword"/>.
        /// </summary>
        /// <param name="candidatePassword">The password to check.</param>
        /// <returns><b>True</b> if the <paramref name="candidatePassword"/> matches the password that created this <see cref="SaltedPassword"/>; otherwise, <b>false</b> indicates a negative match.</returns>
        public bool IsValid(System.Security.SecureString candidatePassword)
        {
            if (candidatePassword == null) { throw new ArgumentNullException(nameof(candidatePassword)); }
            var dude = new SaltedPassword(HashAlgorithmType, candidatePassword, Salt);
            return IsValid(dude);
        }
        #endregion
        #region Configuration.IConfigurationGroup Methods
        /// <summary>
        /// Will populate an <see cref="Core.Configuration.IConfigurationGroup"/> containing data needed to serialize the target object. 
        /// </summary>
        public Configuration.IConfigurationGroup Configuration
        {
            get
            {
                var result = new Configuration.ConfigurationGroup("SaltedPassword");
                result.Items.Add("Type", this.GetType(), typeof(Type));
                result.Items.Add("HashAlgorithmType", HashAlgorithmType, HashAlgorithmType.GetType());
                result.Items.Add("Salt", Salt, Salt.GetType());
                result.Items.Add("PasswordSaltHash", PasswordSaltHash, PasswordSaltHash.GetType());
                return result;
            }
        }
        #endregion
        #region System.Runtime.Serialization.ISerializable Methods
        /// <summary>
        /// Implements the <see cref="System.Runtime.Serialization.ISerializable"/> interface and returns the data needed to serialize the state for this instance.
        /// </summary>
        /// <param name="info">A <see cref="System.Runtime.Serialization.SerializationInfo"/> object that contains the information required to serialize the state instance.</param>
        /// <param name="context">A <see cref="System.Runtime.Serialization.StreamingContext"/> that contains the source and destination of the serialized stream associated with the state instance.</param>
        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("Salt", Salt);
            info.AddValue("PasswordSaltResultHash", PasswordSaltHash);
            info.AddValue("HashAlgorithmType", HashAlgorithmType.AssemblyQualifiedName);
        }
        #endregion
    }
}
