using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace dodSON.Core.Common
{
    /// <summary>
    /// Assists with data integrity and validation by computing hash values using any of the <see cref="System.Security.Cryptography.HashAlgorithm"/> derived types.
    /// Provides methods to compute hash values, in the form of byte arrays, and compare hash values to the hash values of strings, byte arrays, streams and files.
    /// </summary>
    /// <seealso cref="System.Security.Cryptography.HashAlgorithm"/>
    /// <seealso cref="ByteArrayHelper"/>
    /// <seealso cref="ByteArrayHelper.ConvertByteArrayToString(byte[], ByteArrayHelper.ConversionBase, string)"/>
    /// <seealso cref="ByteArrayHelper.ConvertStringToByteArray(string, ByteArrayHelper.ConversionBase)"/>
    /// <example>
    /// <para>
    /// The following example will create (n) files filled with random words and records there (System.Security.Cryptography.HashAlgorithm-based) hash values.
    /// The random words are generated by the <see cref="dodSON.Core.Common.LoremIpsumGenerator"/>.
    /// <br/><br/>
    /// A few of the randomly generated files will be overwritten with new random words.
    /// <br/><br/>
    /// Then, it will read all (n) files, compute there (System.Security.Cryptography.HashAlgorithm-based) hashes, compare them to the recorded hash values and display the results.
    /// </para>
    /// <br/>
    /// <para>Create a console application and add the following code:</para>
    /// <br/>
    /// <code>
    /// static void Main(string[] args)
    /// {
    ///     // ################################################
    ///     // ##### BE SURE TO CHANGE THESE AS NECESSARY #####
    ///     
    ///     string rootPath = @"C:\(WORKING)\Dev\Checksum2";
    ///     int numberOfFilesToProcess = 32;
    ///     int numberOfFilesToModify = 8;
    /// 
    ///     // #### SELECT ONE ( hasher ) FROM BELOW ####
    /// 
    ///     // keyed examples, with random keys using recommended key sizes
    /// 
    ///     //var hasher = new System.Security.Cryptography.MACTripleDES(dodSON.Core.Cryptography.CryptographyHelper.GenerateCryptographicallyRandomArray(16));
    ///     //var hasher = new System.Security.Cryptography.HMACMD5(dodSON.Core.Cryptography.CryptographyHelper.GenerateCryptographicallyRandomArray(64));
    ///     //var hasher = new System.Security.Cryptography.HMACRIPEMD160(dodSON.Core.Cryptography.CryptographyHelper.GenerateCryptographicallyRandomArray(64));
    ///     //var hasher = new System.Security.Cryptography.HMACSHA1(dodSON.Core.Cryptography.CryptographyHelper.GenerateCryptographicallyRandomArray(64), true);
    ///     //var hasher = new System.Security.Cryptography.HMACSHA256(dodSON.Core.Cryptography.CryptographyHelper.GenerateCryptographicallyRandomArray(64));
    ///     //var hasher = new System.Security.Cryptography.HMACSHA384(dodSON.Core.Cryptography.CryptographyHelper.GenerateCryptographicallyRandomArray(128));
    ///     //var hasher = new System.Security.Cryptography.HMACSHA512(dodSON.Core.Cryptography.CryptographyHelper.GenerateCryptographicallyRandomArray(128));
    /// 
    ///     // non-keyed examples
    /// 
    ///     var hasher = new System.Security.Cryptography.MD5CryptoServiceProvider();
    ///     //var hasher = new System.Security.Cryptography.RIPEMD160Managed();
    ///     //var hasher = new System.Security.Cryptography.SHA1Managed();
    ///     //var hasher = new System.Security.Cryptography.SHA256Managed();
    ///     //var hasher = new System.Security.Cryptography.SHA384Managed();
    ///     //var hasher = new System.Security.Cryptography.SHA512Managed();
    /// 
    ///     // ################################################
    ///     // ################################################
    /// 
    ///     // dictionary to store filenames and hash values
    ///     Dictionary&lt;string, byte[]&gt; dict = new Dictionary&lt;string, byte[]&gt;();
    ///     Random rnd = new Random();
    /// 
    ///     // create files with random data and record their hash values
    ///     Console.WriteLine($"Creating {numberOfFilesToProcess:N0} random files and storing their {hasher.GetType().Name} hashes{Environment.NewLine}");
    /// 
    ///     for (int i = 0; i &lt; numberOfFilesToProcess; i++)
    ///     {
    ///         // create randomly generated Lorem Ipsum chapter with 15-30 paragraphs
    ///         string randomStr = dodSON.Core.Common.LoremIpsumGenerator.GenerateChapter(rnd.Next(15, 30), true);
    ///         // write the randomly generated Lorem Ipsum chapter to file
    ///         string filename = System.IO.Path.Combine(rootPath, $"File{i + 1:00}.txt");
    ///         System.IO.File.WriteAllText(filename, randomStr);
    ///         // get the file's hash
    ///         byte[] randomHash = dodSON.Core.Common.ChecksumHelper.ComputeFile(filename, hasher);
    ///         // add the randomly generated file's filename and it's hash value to the dictionary
    ///         dict.Add(filename, randomHash);
    ///         // display the results
    ///         Console.WriteLine($"{System.IO.Path.GetFileName(filename)}\t[{dodSON.Core.Common.ByteArrayHelper.ConvertByteArrayToHexString(randomHash)}]");
    ///     }
    /// 
    ///     // modify some of the randomly generated files
    ///     Console.WriteLine($"{Environment.NewLine}--------------------------------------------------------------");
    ///     Console.WriteLine($"{Environment.NewLine}Modifying {numberOfFilesToModify:N0} random files{Environment.NewLine}");
    ///     SortedList&lt;string, string&gt; modifiedFiles = new SortedList&lt;string, string&gt;();
    ///     for (int i = 0; i &lt; numberOfFilesToModify; i++)
    ///     {
    ///         while (true)
    ///         {
    ///             var rndInt = rnd.Next(1, numberOfFilesToProcess);
    ///             var filename = System.IO.Path.Combine(rootPath, $"File{rndInt:00}.txt");
    ///             if (!modifiedFiles.ContainsKey(filename))
    ///             {
    ///                 modifiedFiles.Add(filename, System.IO.Path.GetFileName(filename));
    ///                 // modify existing file
    ///                 System.IO.File.WriteAllText(filename, dodSON.Core.Common.LoremIpsumGenerator.GenerateChapter(rnd.Next(15, 30), true));
    ///                 break;
    ///             }
    ///         }
    ///     }
    /// 
    ///     // list all of the files that were modified 
    ///     foreach (var modifiedFilename in modifiedFiles)
    ///     {
    ///         Console.WriteLine($"{modifiedFilename.Value}");
    ///     }
    /// 
    ///     // read all files and compare their current hash values to the recorded hash values
    ///     Console.WriteLine($"{Environment.NewLine}--------------------------------------------------------------");
    ///     Console.WriteLine($"{Environment.NewLine}Testing the {numberOfFilesToProcess:N0} random files against the stored {hasher.GetType().Name} hashes{Environment.NewLine}");
    ///     foreach (var item in dict)
    ///     {
    ///         // get the filename and the hash value from the dictionary
    ///         string filename = item.Key;
    ///         byte[] checksum = item.Value;
    ///         // compare the file's actual hash values with the recorded hash values
    ///         var compareResult = dodSON.Core.Common.ChecksumHelper.CompareFile(filename, checksum, hasher);
    ///         var newChecksum = dodSON.Core.Common.ChecksumHelper.ComputeFile(filename, hasher);
    ///         // display the results
    ///         Console.WriteLine($"{System.IO.Path.GetFileName(filename)}\t{compareResult}\t[{dodSON.Core.Common.ByteArrayHelper.ConvertByteArrayToHexString(newChecksum)}]");
    ///     }
    /// 
    ///     // --------
    ///     Console.WriteLine($"{Environment.NewLine}--------------------------------------------------------------");
    ///     Console.Write($"press anykey&gt;");
    ///     Console.ReadKey(true);
    /// }
    /// 
    /// // This code produces output similar to the following:
    /// 
    /// // Creating 32 random files and storing their MD5CryptoServiceProvider hashes
    /// // 
    /// // File01.txt      [AD1FC80B4AE7EB7C8A94761E680A903A]
    /// // File02.txt      [2FDA864C9554A83A3CF6B0CCB9FEB659]
    /// // File03.txt      [94181489C5C2111FFAA39B33F778CBFF]
    /// // File04.txt      [7A97B931B6496F81CD4965014CA6CC02]
    /// // File05.txt      [BE62813F034F4D1A6E1D5208BF1FEFBD]
    /// // File06.txt      [F43FF71DE926BC9EC893C7FB25A4862A]
    /// // File07.txt      [04C5B07B3E08B5FD8E31627FA404C023]
    /// // File08.txt      [0BB24ECB0075015B867EC91FFA3985EC]
    /// // File09.txt      [277233620B9C1A380F7A4B84C6F951B6]
    /// // File10.txt      [2A93E46861833E8DAE6C72DC26C003A9]
    /// // File11.txt      [4E0A634F48707E54616F53238781ECA5]
    /// // File12.txt      [6DA66A3DB2ECD059D1A7CED97ED26227]
    /// // File13.txt      [5848B2F0EDCF3A7D72D7EDF60576FD9C]
    /// // File14.txt      [E0CA4FA4E53A0CF687AC43DB46440516]
    /// // File15.txt      [45AC9AD95516EEBDA6BD7040C8835295]
    /// // File16.txt      [06722E54F032F04CB68FD51A5893484D]
    /// // File17.txt      [C5A2AA6A9E07DBCF991FCC0FE427130D]
    /// // File18.txt      [C67AFC8EAF93DB1481FA826A8017869E]
    /// // File19.txt      [74852D765CD1D45BA7947955CFC035DE]
    /// // File20.txt      [92B7322D1CE94AA58B04C5116971E833]
    /// // File21.txt      [9031DB92EA4E05D0B71C643D918FC87C]
    /// // File22.txt      [EAA0884A3EBA0947E1070CDBC516F59B]
    /// // File23.txt      [2E6E0DE22A18ABC1500666EBBB6710E3]
    /// // File24.txt      [94FB1BEF332CA9E8B87FAD5705D54E7E]
    /// // File25.txt      [FAFE1CCAFEEB3C4D280D1DB7C493A2FD]
    /// // File26.txt      [236E2A2E5FD3FEAFFE3A67E530247E54]
    /// // File27.txt      [3171339494F35B17A6194854CA6FFC23]
    /// // File28.txt      [917E0D7CAABD4E830AF7EEBF396117A0]
    /// // File29.txt      [E8EA1322B7288AD6C301D587AD5A10FE]
    /// // File30.txt      [833745332423B14AB1870C1CDEF6F8A3]
    /// // File31.txt      [9AC8398838C1DEAA071F86C392762B50]
    /// // File32.txt      [2129A9826A715E001E4717D61592F9D5]
    /// // 
    /// // --------------------------------------------------------------
    /// // 
    /// // Modifying 8 random files
    /// // 
    /// // File01.txt
    /// // File07.txt
    /// // File08.txt
    /// // File10.txt
    /// // File18.txt
    /// // File19.txt
    /// // File21.txt
    /// // File25.txt
    /// // 
    /// // --------------------------------------------------------------
    /// // 
    /// // Testing the 32 random files against the stored MD5CryptoServiceProvider hashes
    /// // 
    /// // File01.txt      False   [41C54FA81A53E8349010AD4F2DC0E31F]
    /// // File02.txt      True    [2FDA864C9554A83A3CF6B0CCB9FEB659]
    /// // File03.txt      True    [94181489C5C2111FFAA39B33F778CBFF]
    /// // File04.txt      True    [7A97B931B6496F81CD4965014CA6CC02]
    /// // File05.txt      True    [BE62813F034F4D1A6E1D5208BF1FEFBD]
    /// // File06.txt      True    [F43FF71DE926BC9EC893C7FB25A4862A]
    /// // File07.txt      False   [476F8C68EB54FDB69ED37B8DD54FAF16]
    /// // File08.txt      False   [C3A70D8878F7D7BBD491BDA4E1E8910D]
    /// // File09.txt      True    [277233620B9C1A380F7A4B84C6F951B6]
    /// // File10.txt      False   [577937E894616F570F06DC5FA2212D78]
    /// // File11.txt      True    [4E0A634F48707E54616F53238781ECA5]
    /// // File12.txt      True    [6DA66A3DB2ECD059D1A7CED97ED26227]
    /// // File13.txt      True    [5848B2F0EDCF3A7D72D7EDF60576FD9C]
    /// // File14.txt      True    [E0CA4FA4E53A0CF687AC43DB46440516]
    /// // File15.txt      True    [45AC9AD95516EEBDA6BD7040C8835295]
    /// // File16.txt      True    [06722E54F032F04CB68FD51A5893484D]
    /// // File17.txt      True    [C5A2AA6A9E07DBCF991FCC0FE427130D]
    /// // File18.txt      False   [662704F3A345BEC664876F2FB775780F]
    /// // File19.txt      False   [96710CE0A1BF2987016CC238C72DF458]
    /// // File20.txt      True    [92B7322D1CE94AA58B04C5116971E833]
    /// // File21.txt      False   [355640E70190737CF102A9F994F1190E]
    /// // File22.txt      True    [EAA0884A3EBA0947E1070CDBC516F59B]
    /// // File23.txt      True    [2E6E0DE22A18ABC1500666EBBB6710E3]
    /// // File24.txt      True    [94FB1BEF332CA9E8B87FAD5705D54E7E]
    /// // File25.txt      False   [6986D7A99EAF4A71702DE4D3742286A7]
    /// // File26.txt      True    [236E2A2E5FD3FEAFFE3A67E530247E54]
    /// // File27.txt      True    [3171339494F35B17A6194854CA6FFC23]
    /// // File28.txt      True    [917E0D7CAABD4E830AF7EEBF396117A0]
    /// // File29.txt      True    [E8EA1322B7288AD6C301D587AD5A10FE]
    /// // File30.txt      True    [833745332423B14AB1870C1CDEF6F8A3]
    /// // File31.txt      True    [9AC8398838C1DEAA071F86C392762B50]
    /// // File32.txt      True    [2129A9826A715E001E4717D61592F9D5]
    /// // 
    /// // --------------------------------------------------------------
    /// // press anykey&gt;
    /// </code>
    /// </example>
    public static class ChecksumHelper
    {
        #region Public Methods

        // ######## COMPUTE ########

        /// <summary>
        /// Computes the hash for the given <paramref name="stream"/> into a byte array, using the given <paramref name="hasher"/>.
        /// The hash will be computed for the <paramref name="stream"/> starting at the <paramref name="stream"/>'s current position and continuing to the end of the <paramref name="stream"/>.
        /// Upon return, the stream's position can be reset to the beginning, if the <paramref name="stream"/>'s <see cref="System.IO.Stream.CanSeek"/> is <b>true</b>.
        /// </summary>
        /// <param name="stream">The <see cref="System.IO.Stream"/> to compute the hash for.</param>
        /// <param name="resetStream">If <b>true</b> the stream's position will be reset to the beginning, if the <paramref name="stream"/>'s <see cref="System.IO.Stream.CanSeek"/> is <b>true</b>; otherwise, <b>false</b> will leave the stream's position alone.</param>
        /// <param name="hasher">The type of <see cref="System.Security.Cryptography.HashAlgorithm"/> used to compute hashes.</param>
        /// <returns>The hash for the given <paramref name="stream"/>.</returns>
        public static byte[] Compute(System.IO.Stream stream, bool resetStream, System.Security.Cryptography.HashAlgorithm hasher)
        {
            // validate data
            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }
            if (hasher == null)
            {
                throw new ArgumentNullException(nameof(hasher));
            }
            // compute the hash for the stream
            var hashBytes = hasher.ComputeHash(stream);
            // seek to the beginning of the stream, if possible
            if (resetStream && stream.CanSeek)
            {
                stream.Seek(0, System.IO.SeekOrigin.Begin);
            }
            // return the hexadecimal string version of the computed hash
            return hashBytes;
        }
        /// <summary>
        /// Computes the hash for the given <paramref name="stream"/> into a byte array, using the given <paramref name="hasher"/>.
        /// The hash will be computed for the <paramref name="stream"/> starting at the <paramref name="stream"/>'s current position and continuing to the end of the <paramref name="stream"/>.
        /// The stream's position will be left where it is. (resetStream = false)
        /// </summary>
        /// <param name="stream">The <see cref="System.IO.Stream"/> to compute the hash for.</param>
        /// <param name="hasher">The type of <see cref="System.Security.Cryptography.HashAlgorithm"/> used to compute hashes.</param>
        /// <returns>The hash for the given <paramref name="stream"/>.</returns>
        public static byte[] Compute(System.IO.Stream stream, System.Security.Cryptography.HashAlgorithm hasher) => Compute(stream, false, hasher);
        /// <summary>
        /// Computes the hash for the given string into a byte array, using the given <paramref name="hasher"/>.
        /// </summary>
        /// <param name="source">The string to compute the checksum for.</param>
        /// <param name="hasher">The type of <see cref="System.Security.Cryptography.HashAlgorithm"/> used to compute hashes.</param>
        /// <returns>The hash for the given string.</returns>
        public static byte[] Compute(string source, System.Security.Cryptography.HashAlgorithm hasher)
        {
            // validate data
            if (string.IsNullOrWhiteSpace(source))
            {
                source = string.Empty;
            }
            // open file as stream
            using (var stream = new System.IO.MemoryStream(Encoding.Unicode.GetBytes(source)))
            {
                // compute file's hash
                return Compute(stream, false, hasher);
            }
        }
        /// <summary>
        /// Computes the hash for the given <paramref name="source"/> byte array into a byte array, using the given <paramref name="hasher"/>.
        /// </summary>
        /// <param name="source">The byte array to compute the hash for.</param>
        /// <param name="hasher">The type of <see cref="System.Security.Cryptography.HashAlgorithm"/> used to compute hashes.</param>
        /// <returns>The hash for the given <paramref name="source"/> byte array.</returns>
        public static byte[] Compute(byte[] source, System.Security.Cryptography.HashAlgorithm hasher)
        {
            // validate data
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }
            // open byte[] as stream
            using (var stream = new System.IO.MemoryStream(source))
            {
                // compute byte[]'s hash
                return Compute(stream, false, hasher);
            }
        }

        // ######## COMPARE ########

        /// <summary>
        /// Compares the given <paramref name="stream"/>'s computed hash to the given <paramref name="checksum"/>.
        /// </summary>
        /// <param name="stream">The <see cref="System.IO.Stream"/> to compute the hash for and compare to the <paramref name="checksum"/>.</param>
        /// <param name="checksum">The checksum to compare the given <paramref name="stream"/>'s computed hash to.</param>
        /// <param name="resetStream">If <b>true</b> the stream's position will be reset to the beginning, if the <paramref name="stream"/>'s <see cref="System.IO.Stream.CanSeek"/> is <b>true</b>; otherwise, <b>false</b> will leave the stream's position alone.</param>
        /// <param name="hasher">The type of <see cref="System.Security.Cryptography.HashAlgorithm"/> used to compute hashes.</param>
        /// <returns><b>True</b> indicates the hashes match; otherwise, <b>false</b> indicates that the hashes do not match.</returns>
        public static bool Compare(System.IO.Stream stream, byte[] checksum, bool resetStream, System.Security.Cryptography.HashAlgorithm hasher)
        {
            // validate data
            if ((checksum == null) || (checksum.Length == 0))
            {
                throw new ArgumentNullException(nameof(checksum));
            }
            //
            return CompareChecksums(Compute(stream, resetStream, hasher), checksum);
        }
        /// <summary>
        /// Compares the given <paramref name="stream"/>'s computed hash to the given <paramref name="checksum"/>.
        /// The stream's position will be left where it is. (resetStream = false)
        /// </summary>
        /// <param name="stream">The <see cref="System.IO.Stream"/> to compute the hash for and compare to the <paramref name="checksum"/>.</param>
        /// <param name="checksum">The checksum to compare the given <paramref name="stream"/>'s computed hash to.</param>
        /// <param name="hasher">The type of <see cref="System.Security.Cryptography.HashAlgorithm"/> used to compute hashes.</param>
        /// <returns><b>True</b> indicates the hashes match; otherwise, <b>false</b> indicates that the hashes do not match.</returns>
        public static bool Compare(System.IO.Stream stream, byte[] checksum, System.Security.Cryptography.HashAlgorithm hasher) => Compare(stream, checksum, false, hasher);
        /// <summary>
        /// Compares the given string's computed hash to the given <paramref name="checksum"/>.
        /// </summary>
        /// <param name="source">The string to compute the hash for and compare to the <paramref name="checksum"/>.</param>
        /// <param name="checksum">The checksum to compare the given string's computed hash to.</param>
        /// <param name="hasher">The type of <see cref="System.Security.Cryptography.HashAlgorithm"/> used to compute hashes.</param>
        /// <returns><b>True</b> indicates the string's hash matches the <paramref name="checksum"/>; otherwise, <b>false</b> indicates that the hashes do not match.</returns>
        public static bool Compare(string source, byte[] checksum, System.Security.Cryptography.HashAlgorithm hasher)
        {
            // validate data
            if ((checksum == null) || (checksum.Length == 0))
            {
                throw new ArgumentNullException(nameof(checksum));
            }
            //
            return CompareChecksums(Compute(source, hasher), checksum);
        }
        /// <summary>
        /// Compares the given byte array's computed hash to the given <paramref name="checksum"/>.
        /// </summary>
        /// <param name="source">The byte array to compute the hash for and compare to the <paramref name="checksum"/>.</param>
        /// <param name="checksum">The checksum to compare the given byte array's computed hash to.</param>
        /// <param name="hasher">The type of <see cref="System.Security.Cryptography.HashAlgorithm"/> used to compute hashes.</param>
        /// <returns><b>True</b> indicates the byte array's hash matches the <paramref name="checksum"/>; otherwise, <b>false</b> indicates that the hashes do not match.</returns>
        public static bool Compare(byte[] source, byte[] checksum, System.Security.Cryptography.HashAlgorithm hasher)
        {
            // validate data          
            if ((checksum == null) || (checksum.Length == 0))
            {
                throw new ArgumentNullException(nameof(checksum));
            }
            //
            return CompareChecksums(Compute(source, hasher), checksum);
        }

        // ######## FILES ########

        /// <summary>
        /// Computes the hash for the given file into a byte array, using the given <paramref name="hasher"/>.
        /// </summary>
        /// <param name="filename">The name of the file to compute the checksum for.</param>
        /// <param name="hasher">The type of <see cref="System.Security.Cryptography.HashAlgorithm"/> used to compute hashes.</param>
        /// <returns>The hash for the given file.</returns>
        public static byte[] ComputeFile(string filename, System.Security.Cryptography.HashAlgorithm hasher)
        {
            // validate data
            if (string.IsNullOrWhiteSpace(filename))
            {
                throw new ArgumentNullException(nameof(filename));
            }
            if (!System.IO.File.Exists(filename))
            {
                throw new System.IO.FileNotFoundException(filename);
            }
            //
            if (hasher == null)
            {
                throw new ArgumentNullException(nameof(hasher));
            }
            // open file as stream
            using (var stream = System.IO.File.Open(filename, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.Read))
            {
                // compute and return the hash for the stream, closing the stream upon leaving
                return hasher.ComputeHash(stream);
            }
        }
        /// <summary>
        /// Compares the given file's computed hash to the given <paramref name="checksum"/>.
        /// </summary>
        /// <param name="filename">The name of the file to compute the checksum for.</param>
        /// <param name="checksum">The checksum to compare the given file's computed hash to.</param>
        /// <param name="hasher">The type of <see cref="System.Security.Cryptography.HashAlgorithm"/> used to compute hashes.</param>
        /// <returns>The hash for the given file computed and converted into a byte array.</returns>
        public static bool CompareFile(string filename,
                                       byte[] checksum,
                                       System.Security.Cryptography.HashAlgorithm hasher) => CompareChecksums(ComputeFile(filename, hasher), checksum);
        /// <summary>
        /// Compares two files by computing each file's hashes and comparing the hashes.
        /// </summary>
        /// <param name="file1">The first file, to compare to the second file.</param>
        /// <param name="file2">The second file, to compare to the first file.</param>
        /// <param name="hasher">The type of <see cref="System.Security.Cryptography.HashAlgorithm"/> used to compute hashes.</param>
        /// <returns><b>True</b> indicates the file's hashes matched; otherwise, <b>false</b> indicates that the file's hashes do not match.</returns>
        public static bool CompareFiles(string file1, string file2, System.Security.Cryptography.HashAlgorithm hasher) => CompareFile(file1, ComputeFile(file2, hasher), hasher);
        #endregion
        #region Private Methods
        /// <summary>
        /// Compares two bytes arrays to each other.
        /// </summary>
        /// <param name="checksum1">The first byte array to verify against the second.</param>
        /// <param name="checksum2">The second byte array to verify against the first.</param>
        /// <returns>Whether the bytes arrays matched or not.
        /// <b>True</b> indicates the bytes arrays matched; otherwise, <b>false</b> indicates the bytes arrays did not match.</returns>
        private static bool CompareChecksums(byte[] checksum1, byte[] checksum2) => checksum1.SequenceEqual(checksum2);
        #endregion
    }
}
